(function(d,a){typeof exports=="object"&&typeof module<"u"?a(exports):typeof define=="function"&&define.amd?define(["exports"],a):(d=typeof globalThis<"u"?globalThis:d||self,a(d.AIFormFill={}))})(this,(function(d){"use strict";let a={ollama:{apiEndpoint:"http://localhost:11434",model:"gemma3:4b"},openai:{apiEndpoint:"http://localhost:5173/api",model:"gpt-5-nano"},perplexity:{apiEndpoint:"http://localhost:5173/api",model:"sonar"},providerDebug:!0,formFillDebug:!0,timeout:3e4};class y{chatEndpoint;listModelsEndpoint;availabilityEndpoint;selectedModel;apiEndpoint;timeout;supportsStructuredResponses=!1;constructor(e){this.apiEndpoint=e?.apiEndpoint||"",this.selectedModel=e?.model||"",this.timeout=e?.timeout||3e4}getSelectedModel(){return this.selectedModel}async setSelectedModel(e){if(!e)return!1;try{const t=await this.listModels();return t&&t.includes(e)?(this.selectedModel=e,!0):(a.providerDebug&&console.warn(`Model "${e}" not found. Available: ${t.join(", ")}`),!1)}catch(t){return a.providerDebug&&console.warn("Could not validate model:",t),this.selectedModel=e,!0}}getName(){return this.providerName}supportsStructuredOutput(){return this.supportsStructuredResponses}}class P extends y{providerType="local"}class k extends y{providerType="remote"}const L=["null","","n/a","none","no value","empty","undefined","unknown","missing"],I=["true","yes","1","checked","on"];function h(o){o.dispatchEvent(new Event("input",{bubbles:!0})),o.dispatchEvent(new Event("change",{bubbles:!0}))}function N(o){return L.includes(o)}function D(o){if(o.id){const t=document.querySelector(`label[for="${o.id}"]`);if(t)return t.textContent?.trim()||""}const e=o.closest("label");return e&&e.textContent?.trim()||""}function O(o,e){let t=null;const r=o.trim();if(/^\d{4}-\d{2}-\d{2}/.test(r))t=new Date(r);else if(/^\d{1,2}[\/.-]\d{1,2}[\/.-]\d{2,4}$/.test(r)){const s=r.split(/[\/.-]/),c=parseInt(s[0],10),f=parseInt(s[1],10);let m=parseInt(s[2],10);m<100&&(m+=2e3),t=new Date(m,c-1,f)}else{const s=Date.parse(r);isNaN(s)||(t=new Date(s))}if(e==="time"){const s=r.match(/(\d{1,2}):(\d{2})(?::(\d{2}))?(?:\s*(am|pm))?/i);if(s){let c=parseInt(s[1],10);const f=s[2],m=s[4]?.toLowerCase();return m==="pm"&&c<12&&(c+=12),m==="am"&&c===12&&(c=0),`${c.toString().padStart(2,"0")}:${f}`}return null}if(!t||isNaN(t.getTime()))return null;const i=t.getFullYear(),n=(t.getMonth()+1).toString().padStart(2,"0"),l=t.getDate().toString().padStart(2,"0"),p=t.getHours().toString().padStart(2,"0"),u=t.getMinutes().toString().padStart(2,"0");switch(e){case"date":return`${i}-${n}-${l}`;case"datetime-local":return`${i}-${n}-${l}T${p}:${u}`;case"month":return`${i}-${n}`;case"week":const s=new Date(i,0,1),c=Math.floor((t.getTime()-s.getTime())/(1440*60*1e3)),f=Math.ceil((c+s.getDay()+1)/7);return`${i}-W${f.toString().padStart(2,"0")}`;default:return`${i}-${n}-${l}`}}function b(o){const e={element:o,type:"text"};if(o instanceof HTMLInputElement?(e.type=o.type,e.name=o.name,e.placeholder=o.placeholder,e.pattern=o.pattern,o.type==="checkbox"&&(e.placeholder=o.value||"checkbox option"),o.type==="radio"&&(e.placeholder=o.value||"radio option")):o instanceof HTMLTextAreaElement?(e.type="textarea",e.name=o.name,e.placeholder=o.placeholder):o instanceof HTMLSelectElement&&(e.type="select",e.name=o.name),o.id){const r=document.querySelector(`label[for="${o.id}"]`);r&&(e.label=r.textContent?.trim())}if(!e.label){const r=o.closest("label");r&&(e.label=r.textContent?.trim())}const t=o.dataset.affHint;return t&&(e.hint=t),e}function F(o){const e=[],t=new Map;o.querySelectorAll('input:not([type="submit"]):not([type="reset"]):not([type="button"]):not([type="hidden"]):not([type="image"]):not([type="file"]), textarea, select').forEach(i=>{if(i instanceof HTMLInputElement&&i.type==="radio"){const n=i.name;n&&(t.has(n)||t.set(n,[]),t.get(n).push(i))}else i instanceof HTMLElement&&e.push(b(i))});for(const[i,n]of t.entries()){if(n.length===0)continue;const l=n[0],p=b(l);p.options=n.map(u=>{let s="";if(u.id){const c=document.querySelector(`label[for="${u.id}"]`);c&&(s=c.textContent?.trim()||"")}if(!s){const c=u.closest("label");c&&(s=c.textContent?.trim()||"")}return{value:u.value,label:s||u.value}});for(const u of n){const s=u.dataset.affHint;s&&(p.hint+=" "+s)}e.push(p)}return e}function C(o,e){const t=I.includes(e);o.checked=t,h(o)}function R(o,e){const t=o.closest("form");if(!t||!o.name)return;const r=t.querySelectorAll(`input[type="radio"][name="${o.name}"]`);for(const i of r){const n=D(i).toLowerCase(),l=i.value.toLowerCase();if(l===e||n===e||l.includes(e)||n.includes(e)||e.includes(l)||e.includes(n)){i.checked=!0,h(i);break}}}function Y(o,e){const t=O(e,o.type);t?(o.value=t,h(o)):a.formFillDebug&&console.warn(`Could not parse date value "${e}" for ${o.type} input`)}function j(o,e,t){let r=Array.from(o.options).find(i=>i.value.toLowerCase()===e||i.text.toLowerCase()===e);r||(r=Array.from(o.options).find(i=>i.value.toLowerCase().includes(e)||i.text.toLowerCase().includes(e)||e.includes(i.value.toLowerCase())||e.includes(i.text.toLowerCase()))),r?(o.value=r.value,h(o)):a.formFillDebug&&console.warn(`No matching option for select. Value: "${t}", Options:`,Array.from(o.options).map(i=>`${i.value} (${i.text})`))}function v(o,e){const t=e.trim().toLowerCase();if(!N(t))if(o instanceof HTMLInputElement)switch(o.type){case"checkbox":C(o,t);break;case"radio":R(o,t);break;case"date":case"datetime-local":case"time":Y(o,e);break;default:o.value=e,h(o)}else o instanceof HTMLTextAreaElement?(o.value=e,h(o)):o instanceof HTMLSelectElement&&j(o,t,e)}function $(o){return o.name||o.label||o.placeholder||"unknown"}function S(o,e){let t=`Generate appropriate content for the following form field:

`;return o.label&&(t+=`Field Label: ${o.label}
`),o.name&&(t+=`Field Name: ${o.name}
`),t+=`Field Type: ${o.type}
`,o.placeholder&&(t+=`Placeholder: ${o.placeholder}
`),o.pattern&&(t+=`Pattern/Format: ${o.pattern}
`),e&&(t+=`
Additional Context: ${e}
`),o.type==="checkbox"?t=`${e}
Randomly return "true" or "false", no explanations. Dont repeat your choice too often.`:t+=`
Provide a realistic and appropriate value for this field. Only return the value itself, no explanations.`,t}function M(o,e){let t=`Extract structured data from the following unstructured text and match it to the form fields.

`;t+=`Form fields:
`;for(const r of o){const i=r.name||r.label||r.placeholder||"unknown";if(t+=`- ${i} (type: ${r.type})`,r.label&&(t+=` - Label: "${r.label}"`),r.placeholder&&(t+=` - Placeholder: "${r.placeholder}"`),r.type==="select"&&r.element instanceof HTMLSelectElement){const n=Array.from(r.element.options).map(l=>l.textContent?.trim()||"").filter(l=>l);t+=` - Options: [${n.join(", ")}]`}if(r.type==="radio"&&r.options){const n=r.options.map(l=>l.label||l.value);t+=` - Options: [${n.join(", ")}]`}r.type==="date"?t+=" - Format: YYYY-MM-DD":r.type==="datetime-local"?t+=" - Format: YYYY-MM-DDTHH:MM":r.type==="time"&&(t+=" - Format: HH:MM"),r.hint&&(t+=` - Additional info: ${r.hint}`),t+=`
`}return t+=`
Unstructured text:
${e}


    Extract the relevant information and return it as a JSON object where keys match the field names exactly.
    

    Only include fields where you found relevant data.
    

    For checkbox fields, return "true" if the text indicates the option should be checked, "false" or omit otherwise.
    

    For radio fields, return the value (preferred) or label of the selected option.
    

    Return ONLY the JSON object, no explanations or markdown formatting.
  `,t}const E={FIELD_FILL:"You are a helpful assistant that generates appropriate content for form fields. Provide only the value to fill in the field, without any explanation or additional text.",PARSE_EXTRACT:'You are a helpful assistant that extracts structured data from unstructured text. You must respond ONLY with valid JSON, no explanations or markdown code blocks. If its a checkbox field, return "true" if it should be checked, otherwise return "false" or omit the field.'};function H(o){const e={};for(const t of o){const r=t.name||t.label;if(!r)continue;let i;switch(t.type){case"number":case"range":i={type:"number"};break;case"boolean":case"checkbox":i={type:"boolean"};break;case"url":i={type:"string",format:"uri"};break;case"date":i={type:"string",format:"date"};break;case"datetime-local":i={type:"string",format:"date-time"};break;case"time":i={type:"string",format:"time"};break;default:i={type:"string"};break}if(t.pattern&&(i.pattern=t.pattern),t.placeholder||t.hint){const n=[];t.placeholder&&n.push(t.placeholder),t.hint&&n.push(t.hint),i.description=n.join(" - ")}e[r]=i}return{type:"object",properties:e,additionalProperties:!1}}function T(o){try{let e=o.trim();e=e.replace(/```json\n?/g,"").replace(/```\n?/g,"").trim();const t=JSON.parse(e),r={};for(const[i,n]of Object.entries(t))r[i]=String(n);return r}catch(e){return console.error("Failed to parse JSON response:",e),console.error("Response was:",o),{}}}function J(o){try{return JSON.parse(o),!0}catch{return!1}}class A extends P{providerName="ollama";supportsStructuredResponses=!0;chatEndpoint;listModelsEndpoint;availabilityEndpoint;constructor(e){super({apiEndpoint:e?.apiEndpoint||a.ollama.apiEndpoint,model:e?.model||a.ollama.model,timeout:e?.timeout||a.timeout}),this.chatEndpoint=this.apiEndpoint+"/api/chat",this.listModelsEndpoint=this.apiEndpoint+"/api/tags",this.availabilityEndpoint=this.apiEndpoint+"/api/tags"}async chat(e){const t=new AbortController,r=setTimeout(()=>t.abort(),this.timeout),i=this.chatEndpoint;try{const n={model:e.model,messages:e.messages,stream:!1,options:{num_predict:e.maxTokens}},l=await fetch(i,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n),signal:t.signal});if(!l.ok)throw new Error(`Ollama API error: ${l.status} ${l.statusText}`);const p=await l.json();return{content:p.message.content,model:p.model,finishReason:p.done?"stop":"length"}}catch(n){if(n instanceof Error){if(n.name==="AbortError")throw new Error(`Ollama request timed out after ${this.timeout}ms`);if(n.message.includes("fetch")||n.message.includes("Failed to fetch"))throw new Error(`Failed to connect to Ollama at ${this.apiEndpoint}. Is Ollama running?`)}throw n}finally{clearTimeout(r)}}async listModels(){try{const e=await fetch(this.listModelsEndpoint);if(!e.ok)throw new Error(`Failed to fetch models: ${e.statusText}`);return((await e.json()).models||[]).map(r=>r.name)}catch(e){return console.error("Error listing Ollama models:",e),[]}}async isAvailable(){try{return(await fetch(this.availabilityEndpoint,{method:"GET"})).ok}catch{return!1}}}class w extends k{providerName="openai";supportsStructuredResponses=!0;chatEndpoint;listModelsEndpoint;availabilityEndpoint;constructor(e){super({apiEndpoint:e?.apiEndpoint||a.openai.apiEndpoint,model:e?.model||a.openai.model,timeout:e?.timeout||a.timeout}),this.chatEndpoint=`${this.apiEndpoint}/${this.providerName}/chat`,this.listModelsEndpoint=`${this.apiEndpoint}/${this.providerName}/models`,this.availabilityEndpoint=`${this.apiEndpoint}/${this.providerName}/available`}async chat(e){const t=new AbortController,r=setTimeout(()=>t.abort(),this.timeout),i=this.chatEndpoint;try{const l=await(await fetch(i,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e),signal:t.signal})).json();return a.providerDebug&&console.log(`${this.providerName} response body:`,l),{content:l.choices[0].message.content,model:l.model,finishReason:l.choices[0].finish_reason}}catch(n){if(n instanceof Error){if(n.name==="AbortError")throw new Error(`${this.providerName} request timed out after ${this.timeout}ms`);if(n.message.includes("fetch")||n.message.includes("Failed to fetch"))throw new Error(`Failed to connect to ${this.providerName}. Check your network connection.`)}throw n}finally{clearTimeout(r)}}async listModels(){const e=this.listModelsEndpoint;try{const t=await fetch(e,{method:"POST"});if(!t.ok)throw new Error(`${this.providerName} API error: ${t.status} ${t.statusText}`);return(await t.json()).models}catch(t){if(a.providerDebug)throw new Error(`Error fetching models from ${this.providerName}: ${t}`);return[]}}async isAvailable(){const e=this.availabilityEndpoint;try{return(await fetch(e,{method:"POST"})).ok}catch(t){if(a.providerDebug)throw t;return!1}}}class x extends w{providerName="perplexity";constructor(e){super({apiEndpoint:e?.apiEndpoint||a.perplexity.apiEndpoint,model:e?.model||a.perplexity.model,timeout:e?.timeout||a.timeout}),this.chatEndpoint=`${this.apiEndpoint}/${this.providerName}/chat`,this.listModelsEndpoint=`${this.apiEndpoint}/${this.providerName}/models`,this.availabilityEndpoint=`${this.apiEndpoint}/${this.providerName}/available`}}class g{provider;allowedProviders;selectedFields;constructor(e,t){e instanceof y?this.provider=e:this.provider=g.constructProviderWithName(e,t),this.selectedFields=t?.targetFields,this.allowedProviders=t?.allowedProviders}async fillSingleField(e){const t=b(e);a.formFillDebug&&console.log(`Filling ${t.type} field: ${t.name}`);const r=S(t),i=[{role:"system",content:E.FIELD_FILL},{role:"user",content:r}];try{const n=await this.provider.chat({messages:i,model:this.provider.getSelectedModel()});n.content&&v(e,n.content.trim()),a.formFillDebug&&console.log("Field filled with:",n.content)}catch(n){a.formFillDebug&&console.error("Error during fillSingleField:",n)}}async parseAndFillForm(e,t){const r=F(e);a.formFillDebug&&(console.log("Parsing unstructured text for",r.length,"fields"),console.log("Unstructured text:",r));const i=this.selectedFields?r.filter(s=>s.name&&this.selectedFields.includes(s.name)):r,n=M(i,t);a.formFillDebug&&(console.groupCollapsed("Constructed parse prompt:"),console.log(n),console.groupEnd(),console.log(`Sending prompt to ${this.provider.getName()}'s ${this.provider.getSelectedModel()} model...`));const p={messages:[{role:"system",content:E.PARSE_EXTRACT},{role:"user",content:n}],model:this.provider.getSelectedModel()};this.provider.supportsStructuredOutput()&&(p.format=H(i),a.formFillDebug&&console.log("Using structured output format:",p.format));let u={};try{const s=await this.provider.chat(p);if(!s.content){a.formFillDebug&&console.warn("No content received from AI provider.");return}u=T(s.content)}catch(s){a.formFillDebug&&console.error("Error calling AI provider:",s);return}a.formFillDebug&&console.log("Extracted data:",u);for(const s of i){const c=$(s);if(c&&u[c])try{v(s.element,u[c])}catch(f){a.formFillDebug&&console.error(`Failed to fill field "${c}":`,f)}}}async getAvailableModels(){return this.provider.listModels?await this.provider.listModels():[]}async setSelectedModel(e){return this.provider.setSelectedModel(e)}getSelectedModel(){return this.provider.getSelectedModel()}setFields(e){this.selectedFields=e||void 0}getFields(){return this.selectedFields}async providerAvailable(){return this.provider.isAvailable?await this.provider.isAvailable():!0}setProvider(e){this.provider=e}getProvider(){return this.provider}getListOfAllowedProviders(){return this.allowedProviders}static constructProviderWithName(e,t){const r={apiEndpoint:t?.apiEndpoint||"",model:t?.model||"",timeout:t?.timeout};return{ollama:()=>new A(r),openai:()=>new w(r),perplexity:()=>new x(r)}[e]()}}function q(o="aff-form"){const e=document.getElementById(o),t=document.getElementById("aff-text"),r=document.getElementById("aff-text-button"),i=e.getAttribute("data-aff-provider")||"ollama",n=new g(i,{debug:!0});r?r.addEventListener("click",async()=>{const l=t.value.trim();try{await n.parseAndFillForm(e,l)}catch(p){console.error("Error filling form:",p)}}):console.warn("AI Form Fill button not found")}d.AIFormFill=g,d.AIProvider=y,d.LocalOllamaProvider=A,d.OpenAIProvider=w,d.PerplexityProvider=x,d.SYSTEM_PROMPTS=E,d.affConfig=a,d.analyzeField=b,d.buildFieldPrompt=S,d.buildParsePrompt=M,d.getFieldIdentifier=$,d.getFillTargets=F,d.initializeAFFQuick=q,d.isValidJson=J,d.parseJsonResponse=T,d.setFieldValue=v,Object.defineProperty(d,Symbol.toStringTag,{value:"Module"})}));
