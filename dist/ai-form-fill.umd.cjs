(function(s,a){typeof exports=="object"&&typeof module<"u"?a(exports):typeof define=="function"&&define.amd?define(["exports"],a):(s=typeof globalThis<"u"?globalThis:s||self,a(s.AIFormFill={}))})(this,(function(s){"use strict";let a={providers:{ollama:{apiEndpoint:"http://localhost:11434",model:"gemma3:4b",timeout:3e4,chatEndpoint:"/api/chat",listModelsEndpoint:"/api/tags",availabilityEndpoint:"/api/tags"},openai:{apiEndpoint:"http://localhost:5173/api",model:"gpt-5-nano",timeout:6e4,chatEndpoint:void 0,listModelsEndpoint:void 0,availabilityEndpoint:void 0},perplexity:{apiEndpoint:"http://localhost:5173/api",model:"sonar",timeout:6e4,chatEndpoint:void 0,listModelsEndpoint:void 0,availabilityEndpoint:void 0}},defaults:{debug:!0,timeout:3e4}};class f{chatEndpoint;listModelsEndpoint;availabilityEndpoint;selectedModel;apiEndpoint;timeout;debug=a.defaults.debug;constructor(o){this.apiEndpoint=o.apiEndpoint,this.selectedModel=o.model,this.timeout=o.timeout||3e4}getSelectedModel(){return this.selectedModel}setSelectedModel(o){if(o&&typeof this.listModels=="function"){this.listModels().then(e=>{e&&e.includes(o)?this.selectedModel=o:this.debug&&console.log(`Model "${o}" not found in provider models.`)}).catch(e=>{this.debug&&console.log("listModels failed:",e)});return}}getName(){return this.providerName}}class A extends f{providerType="local"}class P extends f{providerType="remote"}function h(t){const o={element:t,type:"text"};if(t instanceof HTMLInputElement?(o.type=t.type,o.name=t.name,o.placeholder=t.placeholder,o.required=t.required,o.pattern=t.pattern,t.type==="checkbox"&&(o.placeholder=t.value||"checkbox option")):t instanceof HTMLTextAreaElement?(o.type="textarea",o.name=t.name,o.placeholder=t.placeholder,o.required=t.required):t instanceof HTMLSelectElement&&(o.type="select",o.name=t.name,o.required=t.required),t.id){const e=document.querySelector(`label[for="${t.id}"]`);e&&(o.label=e.textContent?.trim())}if(!o.label){const e=t.closest("label");e&&(o.label=e.textContent?.trim())}return o}function E(t){const o=[];return t.querySelectorAll('input:not([type="submit"]):not([type="button"]):not([type="reset"]), textarea, select').forEach(i=>{i instanceof HTMLElement&&o.push(h(i))}),o}function m(t,o){const e=o.trim().toLowerCase();if(!(e=="null"||e===""||e==="n/a"||e==="none"||e==="no value"||e==="empty"||e==="undefined"||e==="unknown")){if(t instanceof HTMLInputElement)if(t.type==="checkbox"){const i=e==="true"||e==="yes"||e==="1"||e==="checked"||e==="on";t.checked=i,t.dispatchEvent(new Event("change",{bubbles:!0})),t.dispatchEvent(new Event("input",{bubbles:!0}))}else t.value=o,t.dispatchEvent(new Event("input",{bubbles:!0})),t.dispatchEvent(new Event("change",{bubbles:!0}));else if(t instanceof HTMLTextAreaElement)t.value=o,t.dispatchEvent(new Event("input",{bubbles:!0})),t.dispatchEvent(new Event("change",{bubbles:!0}));else if(t instanceof HTMLSelectElement){let i=Array.from(t.options).find(n=>n.value.toLowerCase()===e||n.text.toLowerCase()===e);i||(i=Array.from(t.options).find(n=>n.value.toLowerCase().includes(e)||n.text.toLowerCase().includes(e)||e.includes(n.value.toLowerCase())||e.includes(n.text.toLowerCase()))),i?(t.value=i.value,t.dispatchEvent(new Event("change",{bubbles:!0})),t.dispatchEvent(new Event("input",{bubbles:!0}))):a.defaults.debug&&console.warn(`No matching option found for select element. Value: "${o}", Available options:`,Array.from(t.options).map(n=>`${n.value} (${n.text})`))}}}function y(t){return t.name||t.label||t.placeholder||"unknown"}function g(t,o){let e=`Generate appropriate content for the following form field:

`;return t.label&&(e+=`Field Label: ${t.label}
`),t.name&&(e+=`Field Name: ${t.name}
`),e+=`Field Type: ${t.type}
`,t.placeholder&&(e+=`Placeholder: ${t.placeholder}
`),t.pattern&&(e+=`Pattern/Format: ${t.pattern}
`),o&&(e+=`
Additional Context: ${o}
`),t.type==="checkbox"?e=`${o}
Randomly return "true" or "false", no explanations. Dont repeat your choice too often.`:e+=`
Provide a realistic and appropriate value for this field. Only return the value itself, no explanations.`,e}function w(t,o){let e=`Extract structured data from the following unstructured text and match it to the form fields.

`;e+=`Form fields:
`;for(const i of t){const n=i.name||i.label||i.placeholder||"unknown";if(e+=`- ${n} (type: ${i.type})`,i.label&&(e+=` - Label: "${i.label}"`),i.placeholder&&(e+=` - Placeholder: "${i.placeholder}"`),i.type==="select"&&i.element instanceof HTMLSelectElement){const r=Array.from(i.element.options).map(l=>l.textContent?.trim()||"").filter(l=>l);e+=` - Options: [${r.join(", ")}]`}e+=`
`}return e+=`
Unstructured text:
${o}


    Extract the relevant information and return it as a JSON object where keys match the field names exactly.
    

    Only include fields where you found relevant data.
    

    For checkbox fields, return "true" if the text indicates the option should be checked, "false" or omit otherwise.
    

    Return ONLY the JSON object, no explanations or markdown formatting.
  `,e}const v={FIELD_FILL:"You are a helpful assistant that generates appropriate content for form fields. Provide only the value to fill in the field, without any explanation or additional text.",PARSE_EXTRACT:'You are a helpful assistant that extracts structured data from unstructured text. You must respond ONLY with valid JSON, no explanations or markdown code blocks. If its a checkbox field, return "true" if it should be checked, otherwise return "false" or omit the field.'};function F(t){try{let o=t.trim();o=o.replace(/```json\n?/g,"").replace(/```\n?/g,"").trim();const e=JSON.parse(o),i={};for(const[n,r]of Object.entries(e))i[n]=String(r);return i}catch(o){return console.error("Failed to parse JSON response:",o),console.error("Response was:",t),{}}}function L(t){try{return JSON.parse(t),!0}catch{return!1}}class $ extends A{providerName="Ollama";async chat(o){const e=new AbortController,i=setTimeout(()=>e.abort(),this.timeout),n=this.chatEndpoint||`${this.apiEndpoint}${a.providers.ollama.chatEndpoint}`;try{const r={model:o.model||a.providers.ollama.model,messages:o.messages,stream:!1,options:{num_predict:o.maxTokens}},l=await fetch(n,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r),signal:e.signal});if(!l.ok)throw new Error(`Ollama API error: ${l.status} ${l.statusText}`);const d=await l.json();return{content:d.message.content,model:d.model,finishReason:d.done?"stop":"length"}}catch(r){if(r instanceof Error){if(r.name==="AbortError")throw new Error(`Ollama request timed out after ${this.timeout}ms`);if(r.message.includes("fetch")||r.message.includes("Failed to fetch"))throw new Error(`Failed to connect to Ollama at ${this.apiEndpoint}. Is Ollama running?`)}throw r}finally{clearTimeout(i)}}async listModels(){try{const o=await fetch(`${this.apiEndpoint}${a.providers.ollama.listModelsEndpoint}`);if(!o.ok)throw new Error(`Failed to fetch models: ${o.statusText}`);return((await o.json()).models||[]).map(i=>i.name)}catch(o){return console.error("Error listing Ollama models:",o),[]}}async isAvailable(){try{return(await fetch(`${this.apiEndpoint}${a.providers.ollama.availabilityEndpoint}`,{method:"GET"})).ok}catch{return!1}}}class b extends P{providerName="OpenAI";async chat(o){const e=new AbortController,i=setTimeout(()=>e.abort(),this.timeout),n=this.chatEndpoint||`${this.apiEndpoint}/${this.providerName.toLocaleLowerCase()}/chat`;try{const r=await fetch(n,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(o),signal:e.signal});this.debug&&console.log(`${this.providerName} request sent:`,o);const l=await r.json();return this.debug&&console.log(`${this.providerName} response body:`,l),{content:l.choices[0].message.content,model:l.model,finishReason:l.choices[0].finish_reason}}catch(r){if(r instanceof Error){if(r.name==="AbortError")throw new Error(`${this.providerName} request timed out after ${this.timeout}ms`);if(r.message.includes("fetch")||r.message.includes("Failed to fetch"))throw new Error(`Failed to connect to ${this.providerName}. Check your network connection.`)}throw r}finally{clearTimeout(i)}}async listModels(){const o=a.providers.openai.listModelsEndpoint?`${this.apiEndpoint}${a.providers.openai.listModelsEndpoint}`:`${this.apiEndpoint}/${this.providerName.toLocaleLowerCase()}/models`;try{const e=await fetch(o,{method:"POST"});if(!e.ok)throw new Error(`${this.providerName} API error: ${e.status} ${e.statusText}`);return(await e.json()).models}catch(e){if(this.debug)throw new Error(`Error fetching models from ${this.providerName}: ${e}`);return[]}}async isAvailable(){const o=a.providers.openai.availabilityEndpoint?`${this.apiEndpoint}${a.providers.openai.availabilityEndpoint}`:`${this.apiEndpoint}/${this.providerName.toLocaleLowerCase()}/available`;try{return(await fetch(o,{method:"POST"})).ok}catch(e){if(this.debug)throw e;return!1}}}class T extends b{providerName="Perplexity"}class x{provider;debug=a.defaults.debug;context;selectedFields;constructor(o,e){const i={ollama:()=>new $({apiEndpoint:e?.apiEndpoint||a.providers.ollama.apiEndpoint,model:e?.model||a.providers.ollama.model,timeout:e?.timeout||a.providers.ollama.timeout}),openai:()=>new b({apiEndpoint:e?.apiEndpoint||a.providers.openai.apiEndpoint,model:e?.model||a.providers.openai.model,timeout:e?.timeout||a.providers.openai.timeout}),perplexity:()=>new T({apiEndpoint:e?.apiEndpoint||a.providers.perplexity.apiEndpoint,model:e?.model||a.providers.perplexity.model,timeout:e?.timeout||a.providers.perplexity.timeout})},n=o.toLowerCase(),r=i[n];if(!r)throw new Error(`Unsupported provider: ${o}
Available providers: ${Object.keys(i).join(", ")}`);const l=r();this.provider=l,this.debug=e?.debug||a.defaults.debug}async fillSingleField(o){const e=h(o);this.debug&&console.log(`Filling ${e.type} field: ${e.name}`);const i=g(e,this.context),n=[{role:"system",content:v.FIELD_FILL},{role:"user",content:i}];try{const r=await this.provider.chat({messages:n,model:this.provider.getSelectedModel()});r.content&&m(o,r.content.trim()),this.debug&&console.log("Field filled with:",r.content)}catch(r){this.debug&&console.error("Error during fillSingleField:",r)}}async parseAndFillForm(o,e){const i=E(o);this.debug&&console.log("Parsing unstructured text for",i.length,"fields");const n=this.selectedFields?i.filter(c=>c.name&&this.selectedFields.includes(c.name)):i,r=w(n,e);this.debug&&console.log(`Constructed parse prompt:
`,r);const l=[{role:"system",content:v.PARSE_EXTRACT},{role:"user",content:r}],d=await this.provider.chat({messages:l,model:this.provider.getSelectedModel()});let p={};if(d.content)p=F(d.content);else throw new Error("No content received from AI provider.");this.debug&&console.log("Extracted data:",p);for(const c of n){const u=y(c);if(u&&p[u])try{m(c.element,p[u])}catch(O){this.debug&&console.error(`Failed to fill field "${u}":`,O)}}}async providerAvailable(){return this.provider.isAvailable?await this.provider.isAvailable():!0}async getAvailableModels(){return this.provider.listModels?await this.provider.listModels():[]}}function M(){const t=document.getElementById("aff-form"),o=document.getElementById("aff-text"),e=document.getElementById("aff-text-button"),i=document.getElementById("aff-clear-button"),n=t.getAttribute("data-aff-provider")||"Ollama",r=new x(n,{debug:!0});e.addEventListener("click",async()=>{const l=o.value.trim();try{await r.parseAndFillForm(t,l)}catch(d){console.error("Error filling form:",d),alert("Error filling form. Check console for details.")}}),i.addEventListener("click",()=>{t.reset()})}s.AIFormFill=x,s.AIProvider=f,s.LocalOllamaProvider=$,s.OpenAIProvider=b,s.PerplexityProvider=T,s.SYSTEM_PROMPTS=v,s.affConfig=a,s.analyzeField=h,s.buildFieldPrompt=g,s.buildParsePrompt=w,s.getFieldIdentifier=y,s.getFillTargets=E,s.initializeAFFQuick=M,s.isValidJson=L,s.parseJsonResponse=F,s.setFieldValue=m,Object.defineProperty(s,Symbol.toStringTag,{value:"Module"})}));
